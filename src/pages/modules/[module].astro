---
import Layout from "../../layouts/Layout.astro";
import ModuleNav from "../../components/ModuleNav.astro";
// Import specific constants and path utils
import * as DeclCategories from "../../lib/constants";
import { getDeclPath, getModuleSourcePath } from "../../lib/pathUtils";
// Import main data functions from docParser
import { getFieldData } from "../../lib/docParser";
import Link from "../../components/Link.astro";

// Generate all module pages at build time
export async function getStaticPaths() {
  // Ensure WASM is initialized
  // await initWasm(); // May not be needed depending on Astro setup

  const {
    getAllModules: getAllModulesInternal,
    getModuleData: getModuleDataInternal,
  } = await import("../../lib/docParser"); // Dynamic import if needed

  const modules = await getAllModulesInternal();

  // Use Promise.allSettled to handle potential errors for individual modules
  const results = await Promise.allSettled(
    modules.map(async (module) => {
      try {
        const moduleData = await getModuleDataInternal(module.name);
        return {
          params: { module: module.name },
          props: { moduleData: { ...moduleData, moduleName: module.name } }, // Keep moduleName here for convenience
        };
      } catch (error) {
        console.error(
          `Error fetching data for module ${module.name} in getStaticPaths:`,
          error
        );
        // Throw error to mark this path as failed if needed, or return null to skip
        throw new Error(`Failed to generate path for ${module.name}`);
        // return null; // Alternative: skip path on error
      }
    })
  );

  // Filter out rejected promises and extract fulfilled values
  const paths = results
    .filter((result) => result.status === "fulfilled")
    .map((result) => (result as PromiseFulfilledResult<any>).value);
  // .filter(p => p !== null); // Only needed if returning null on error

  console.log(`Successfully prepared ${paths.length} paths for module pages.`);
  return paths;
}

const { module } = Astro.params; // The module name from the URL
const { moduleData } = Astro.props; // Received from getStaticPaths

// --- Process declarations into categories ---
const typesList: any[] = [];
const namespacesList: any[] = [];
const errSetsList: any[] = [];
const fnsList: any[] = [];
const varsList: any[] = []; // Includes global vars and consts
const valsList: any[] = []; // Includes primitives
// Use constants from the imported module
moduleData.declarations.forEach((decl: { category: any; fqn: any }) => {
  switch (decl.category) {
    case DeclCategories.CAT_namespace:
      namespacesList.push(decl);
      break;
    case DeclCategories.CAT_container:
    case DeclCategories.CAT_type:
    case DeclCategories.CAT_type_type:
      typesList.push(decl);
      break;
    case DeclCategories.CAT_type_function:
      // Grouping with Types for now
      typesList.push(decl);
      break;
    case DeclCategories.CAT_global_variable:
    case DeclCategories.CAT_global_const:
      varsList.push(decl);
      break;
    case DeclCategories.CAT_function:
      fnsList.push(decl);
      break;
    case DeclCategories.CAT_error_set:
      errSetsList.push(decl);
      break;
    case DeclCategories.CAT_primitive:
      valsList.push(decl);
      break;
    case DeclCategories.CAT_alias:
      // Aliases should be resolved by processDeclarations, but handle defensively
      console.warn(
        `Unexpected unresolved alias found in module ${module}: ${decl.fqn}`
      );
      // Decide where to put unresolved aliases, maybe Types?
      // typesList.push(decl);
      break;
    default:
      console.warn(
        `Unknown category ${decl.category} for declaration ${decl.fqn} in module ${module}`
      );
    // Add to a generic list or ignore
  }
});

// Sort lists alphabetically by name
const sortByName = (a: { name: string }, b: { name: string }) =>
  a.name.localeCompare(b.name);
typesList.sort(sortByName);
namespacesList.sort(sortByName);
errSetsList.sort(sortByName);
fnsList.sort(sortByName);
varsList.sort(sortByName);
valsList.sort(sortByName);

// Fetch field data if the module itself has fields
let moduleFieldsHtml: any[] = [];
if (moduleData.fields?.length > 0) {
  moduleFieldsHtml = await Promise.all(
    moduleData.fields.map((fieldIndex: number) =>
      getFieldData(moduleData.rootDeclIndex, fieldIndex)
    )
  );
}

// Determine the source path for the module file itself using path util
const moduleSourceLink = getModuleSourcePath(module);
---

<Layout title={`${module} - Zig Documentation`}>
  <main>
    {/* Pass the module name as the current path */}
    <ModuleNav currentPath={module} />

    <h1 id="hdrName">
      <span>module {module}</span>
      {/* Link to the source file of the module */}
      <Link href={moduleSourceLink} target="_blank" title="View source"
        >[src]</Link
      >
    </h1>

    <!-- Module documentation -->
    {
      moduleData.docs && (
        <div id="tldDocs" class="docs" set:html={moduleData.docs} />
      )
    }

    <!-- Types (Structs, Enums, Unions, Type Functions) -->
    {
      typesList.length > 0 && (
        <section id="sectTypes">
          <h2>Types</h2>
          <ul id="listTypes" class="columns">
            {typesList.map((type) => (
              <li>
                {/* Use path util for link */}
                <Link href={getDeclPath(type.fqn)}>{type.name}</Link>
                {/* Optionally show alias info if needed */}
                {/* {type.originalIndex !== type.targetIndex && <span class="alias-info"> (alias for {type.targetFqn})</span>} */}
              </li>
            ))}
          </ul>
        </section>
      )
    }

    <!-- Namespaces -->
    {
      namespacesList.length > 0 && (
        <section id="sectNamespaces">
          <h2>Namespaces</h2>
          <ul id="listNamespaces" class="columns">
            {namespacesList.map((namespace) => (
              <li>
                <Link href={getDeclPath(namespace.fqn)}>{namespace.name}</Link>
              </li>
            ))}
          </ul>
        </section>
      )
    }

    <!-- Error Sets -->
    {
      errSetsList.length > 0 && (
        <section id="sectErrSets">
          <h2>Error Sets</h2>
          <ul id="listErrSets" class="columns">
            {errSetsList.map((errSet) => (
              <li>
                <Link href={getDeclPath(errSet.fqn)}>{errSet.name}</Link>
              </li>
            ))}
          </ul>
        </section>
      )
    }

    <!-- Functions -->
    {
      fnsList.length > 0 && (
        <section id="sectFns">
          <h2>Functions</h2>
          <dl id="listFns">
            {fnsList.map((fn) => (
              <div class="decl-entry">
                <dt style={{ display: "flex", columnGap: "0.5em" }}>
                  {fn.protoHtmlShort && (
                    <Link href={getDeclPath(fn.fqn)}>
                      <code>{fn.protoHtmlShort.replace(fn.name, "")}</code>
                    </Link>
                  )}
                </dt>
                {/* Use short docs */}
                {fn.docsShort && (
                  <dd class="docs-short" set:html={fn.docsShort} />
                )}
              </div>
            ))}
          </dl>
        </section>
      )
    }

    <!-- Global Variables & Constants -->
    {
      varsList.length > 0 && (
        <section id="sectGlobalVars">
          <h2>Global Variables & Constants</h2>
          <table>
            <tbody id="listGlobalVars">
              {varsList.map((variable) => (
                <tr>
                  <td class="decl-name">
                    <Link href={getDeclPath(variable.fqn)}>
                      {variable.name}
                    </Link>
                  </td>
                  {/* Use type HTML */}
                  {/* <td class="decl-type">
                    {variable.typeHtml && <div set:html={variable.typeHtml} />}
                  </td> */}
                  {/* Use short docs */}
                  {/* <td class="docs-short" set:html={variable.docsShort} /> */}
                </tr>
              ))}
            </tbody>
          </table>
        </section>
      )
    }

    <!-- Values (Primitives, etc.) -->
    {
      valsList.length > 0 && (
        <section id="sectValues">
          <h2>Values</h2>
          <table>
            <tbody id="listValues">
              {valsList.map((value) => (
                <tr>
                  <td class="decl-name">
                    {/* Primitives might not have unique pages, link carefully */}
                    {value.category === DeclCategories.CAT_primitive ? (
                      <span>{value.name}</span>
                    ) : (
                      <Link href={getDeclPath(value.fqn)}>{value.name}</Link>
                    )}
                  </td>
                  <td class="decl-type">
                    {value.typeHtml && <div set:html={value.typeHtml} />}
                  </td>
                  <td class="docs-short" set:html={value.docsShort} />
                </tr>
              ))}
            </tbody>
          </table>
        </section>
      )
    }

    <!-- Fields (If the module file itself acts as a container) -->
    {
      moduleFieldsHtml.length > 0 && (
        <section id="sectFields">
          <h2>Fields</h2>
          <div id="listFields">
            {moduleFieldsHtml.map((field) => (
              <div class="field-entry" set:html={field.html} />
            ))}
          </div>
        </section>
      )
    }
  </main>
</Layout>

<!-- Styles remain the same -->
<style>
  /* ... existing styles ... */
  h1 {
    border-bottom: 1px dashed;
    margin: 0 0 0.5em 0;
    padding-bottom: 0.3em;
    font-size: 1.8em; /* Slightly larger */
    font-weight: normal;
  }

  h2 {
    font-size: 1.4em;
    margin: 1.5em 0 0.5em 0;
    padding: 0 0 0.2em 0;
    border-bottom: 1px solid;
    font-weight: normal;
  }

  section {
    margin-bottom: 1.5em;
  }

  #hdrName span {
    font-family: "Source Code Pro", monospace;
  }

  #hdrName a {
    font-size: 0.7em;
    padding-left: 1em;
    font-family: sans-serif;
    font-weight: normal;
    text-decoration: none;
    color: #888;
  }
  #hdrName a:hover {
    color: #000;
  }

  ul.columns {
    column-width: 20em;
    list-style-type: none;
    margin: 0;
    padding: 0;
  }

  ul.columns li {
    padding: 0.1em 0; /* Tighter spacing */
    overflow-wrap: break-word; /* Prevent long names overflowing */
  }
  ul.columns a {
    font-family: "Source Code Pro", monospace;
  }

  table {
    width: 100%;
    border-spacing: 0;
    margin-bottom: 1em;
    table-layout: fixed; /* Prevent wide columns pushing others */
  }

  td {
    text-align: left;
    vertical-align: top;
    margin: 0;
    padding: 0.5em;
    border-bottom: 1px solid #eee; /* subtle row separator */
    overflow-wrap: break-word;
  }
  td.decl-name {
    width: 25%;
    font-family: "Source Code Pro", monospace;
  }
  td.decl-type {
    width: 30%;
  }
  td.docs-short {
    width: 45%;
    color: #555;
    font-size: 0.9em;
  }
  td.docs-short p {
    /* Assuming docs might have <p> tags */
    margin: 0;
  }
  td code {
    font-size: 0.95em;
  } /* Ensure code tags in table are consistent */

  dl#listFns > div.decl-entry {
    padding: 0.5em;
    border: 1px solid #e0e0e0;
    margin-top: 0.5em;
    background-color: #fdfdfd;
    border-radius: 3px; /* Slight rounding */
  }
  dl#listFns dt {
    font-family: "Source Code Pro", monospace;
    font-size: 1.05em;
    margin-bottom: 0.3em;
  }
  /* Separate link for name from rest of proto */
  dl#listFns dt a code {
    font-weight: bold;
  }
  dl#listFns dt code {
    font-size: 0.95em;
  } /* Consistent code size */
  dl#listFns dd.docs-short {
    margin-left: 1em;
    font-size: 0.9em;
    color: #555;
  }
  dl#listFns dd.docs-short p {
    margin: 0;
  }

  #tldDocs {
    margin: 1em 0 2em 0; /* More space around module docs */
    line-height: 1.6;
  }
  #tldDocs p {
    margin: 0.5em 0;
  }

  #listFields > .field-entry {
    /* Style fields if needed, assuming getFieldData returns appropriate HTML */
    border-bottom: 1px solid #eee;
    padding: 0.5em 0;
  }
  #listFields > .field-entry:last-child {
    border-bottom: none;
  }

  .alias-info {
    /* Style for optional alias info */
    font-size: 0.8em;
    color: #777;
    margin-left: 0.5em;
  }

  /* Dark mode adjustments */
  @media (prefers-color-scheme: dark) {
    h1 {
      border-bottom-color: #555;
    }
    h2 {
      border-bottom-color: #666;
    }
    #hdrName a {
      color: #aaa;
    }
    #hdrName a:hover {
      color: #fff;
    }
    td {
      border-bottom-color: #333;
    }
    td.docs-short,
    dd.docs-short {
      color: #bbb;
    }
    dl#listFns > div.decl-entry {
      border-color: #444;
      background-color: #222;
    }
    #listFields > .field-entry {
      border-bottom-color: #333;
    }
    .alias-info {
      color: #aaa;
    }
  }
</style>

<script>
  import { codeToHtml } from "../../lib/codeToHtml";

  const codesElements = document.getElementsByTagName("code");

  await Promise.all(
    Array.from(codesElements).map(async (codeElement) => {
      const codeOriginal = codeElement.innerHTML;
      codeElement.innerHTML = await codeToHtml(codeOriginal);
    })
  );
</script>
