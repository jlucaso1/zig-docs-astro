---
import Layout from "../../../layouts/Layout.astro";
import ModuleNav from "../../../components/ModuleNav.astro";
// Import specific constants and path util
import * as DeclCategories from "../../../lib/constants";
import { getDeclPath, getSourcePath } from "../../../lib/pathUtils";
// Import main data functions from docParser
import {
  getParamData,
  getFieldData,
  getErrorData,
  processDeclarations,
  wasmExports,
} from "../../../lib/docParser"; // Keep wasmExports/unwrapString if needed directly
import { unwrapString } from "../../../lib/wasmUtils";
import Link from "../../../components/Link.astro";
import { generateDeclarationPaths } from "../../../lib/pathGenerator";
// Import the new path generator function

// Use the cached path generator instead of the heavy inline logic
export async function getStaticPaths() {
  // pass true to force regeneration if needed (e.g. when source files change)
  const forceRegenerate = false; // Set to true when needed or via env variable
  return await generateDeclarationPaths(forceRegenerate);
}

interface Props {
  declData: any;
}

// --- Frontmatter ---
const { declData } = Astro.props; // Received from getStaticPaths
// Fetch related data (params, fields, errors) using helper functions
let paramsHtml = [];
if (declData.params?.length > 0) {
  paramsHtml = await Promise.all(
    declData.params.map((paramIndex: number) =>
      getParamData(declData.index, paramIndex)
    )
  );
}

let fieldsHtml = [];
if (declData.fields?.length > 0) {
  fieldsHtml = await Promise.all(
    declData.fields.map((fieldIndex: number) =>
      getFieldData(declData.index, fieldIndex)
    )
  );
}

let errorsHtml = [];
// Use targetIndex for error set base decl logic if appropriate
const errorBaseIndex = declData.errorSetBaseDecl ?? declData.index; // Use self if base not specified
if (errorBaseIndex !== 0xffffffff && declData.errorSetNodes?.length > 0) {
  errorsHtml = await Promise.all(
    declData.errorSetNodes.map((errorNode: bigint) =>
      getErrorData(errorBaseIndex, errorNode)
    )
  );
}

// Process nested members if this is a namespace or container type
let nestedDeclarations: any[] = [];
if (
  (declData.category === DeclCategories.CAT_container ||
    declData.category === DeclCategories.CAT_namespace ||
    declData.category === DeclCategories.CAT_type) && // Include CAT_type if they can have members
  declData.members?.length > 0
) {
  // Re-use processDeclarations helper from docParser
  nestedDeclarations = await processDeclarations(declData.members);
  // Sort members alphabetically by name
  nestedDeclarations.sort((a, b) => a.name.localeCompare(b.name));
}

// Determine source link
const sourceLink = getSourcePath(declData.filePath);
// Determine alias link
const aliasLink = getDeclPath(declData.targetFqn);
---

<Layout
  title={`${declData.name} (${declData.categoryName}) - Zig Documentation`}
>
  <main>
    {/* Pass the full FQN to ModuleNav */}
    <ModuleNav currentPath={declData.fqn} />

    <!-- Declaration Header -->
    <h1 id="hdrName">
      <span>{declData.categoryName} {declData.name}</span>
      {/* Link to source using filePath */}
      <Link href={sourceLink} target="_blank" title="View source">[src]</Link>
    </h1>
    {
      declData.isAlias && (
        <p class="alias-note">
          Alias for <Link href={aliasLink}>{declData.targetFqn}</Link>
        </p>
      )
    }

    <!-- Full Documentation -->
    {
      declData.docs && (
        <div id="tldDocs" class="docs" set:html={declData.docs} />
      )
    }

    <!-- Function/Type Function Specifics -->
    {
      (declData.category === DeclCategories.CAT_function ||
        declData.category === DeclCategories.CAT_type_function) && (
        <>
          {declData.protoHtml && (
            <section id="sectFnProto">
              <h2>Prototype</h2>
              <div class="fn-proto">
                <code>
                  <Fragment set:html={declData.protoHtml} />
                </code>
              </div>
            </section>
          )}

          {paramsHtml.length > 0 && (
            <section id="sectParams">
              <h2>Parameters</h2>
              <div id="listParams" class="fn-proto">
                {paramsHtml.map((param) => (
                  <code set:html={param.html} />
                ))}
              </div>
            </section>
          )}

          {errorsHtml.length > 0 && (
            <section id="sectFnErrors">
              <h2>Possible Errors</h2>
              <div id="tableFnErrors">
                {errorsHtml.map((error) => (
                  <div class="error-entry" set:html={error.html} />
                ))}
              </div>
            </section>
          )}

          {declData.doctestHtml && (
            <section id="sectDocTests">
              <h2>Example</h2>
              <div class="doctest">
                <code>
                  <Fragment set:html={declData.doctestHtml} />
                </code>
              </div>
            </section>
          )}
        </>
      )
    }

    {/* Container/Type/Namespace Specifics (Fields & Members) */}
    {
      (declData.category === DeclCategories.CAT_container ||
        declData.category === DeclCategories.CAT_type ||
        declData.category === DeclCategories.CAT_namespace) && (
        <>
          {fieldsHtml.length > 0 && (
            <section id="sectFields">
              <h2>Fields</h2>
              <div id="listFields">
                {fieldsHtml.map((field) => (
                  <div class="field-entry" set:html={field.html} />
                ))}
              </div>
            </section>
          )}

          {nestedDeclarations.length > 0 && (
            <section id="sectMembers">
              <h2>Members</h2>
              <ul class="nested-list columns">
                {nestedDeclarations.map((member) => {
                  // Create the proper URL for nested declarations using path util
                  const memberPath = getDeclPath(member.fqn);
                  // Get category name using wasmExports if not already in member data
                  const categoryName =
                    member.category !== undefined
                      ? unwrapString(
                          wasmExports.decl_category_name(member.targetIndex)
                        )
                      : "unknown";
                  return (
                    <li>
                      <Link href={memberPath}>{member.name}</Link>
                      <span class="nested-category"> ({categoryName})</span>
                    </li>
                  );
                })}
              </ul>
            </section>
          )}

          {/* Show doctest for containers/types if available and not already shown for functions */}
          {declData.doctestHtml &&
            !(
              declData.category === DeclCategories.CAT_function ||
              declData.category === DeclCategories.CAT_type_function
            ) && (
              <section id="sectDocTests">
                <h2>Example</h2>
                <div class="doctest">
                  <code>
                    <Fragment set:html={declData.doctestHtml} />
                  </code>
                </div>
              </section>
            )}
        </>
      )
    }

    <!-- Error Set Specifics -->
    {
      declData.category === DeclCategories.CAT_error_set &&
        errorsHtml.length > 0 && (
          <section id="sectErrSetErrors">
            <h2>Errors</h2>
            <div id="listErrSetErrors">
              {errorsHtml.map((error) => (
                <div class="error-entry" set:html={error.html} />
              ))}
            </div>
          </section>
        )
    }

    <!-- Variable/Constant Specifics -->
    {
      (declData.category === DeclCategories.CAT_global_variable ||
        declData.category === DeclCategories.CAT_global_const) &&
        declData.typeHtml && (
          <section id="sectVarType">
            <h2>Type</h2>
            <p>
              <Fragment set:html={declData.typeHtml} />
            </p>
          </section>
        )
    }

    <!-- Source Code Section (Always show if available) -->
    {
      !import.meta.env.HIDE_SOURCES && declData.sourceHtml && (
        <section id="sectSource">
          <h2>Source</h2>
          <div class="source-code">
            <code id="sourceCode">
              <Fragment set:html={declData.sourceHtml} />
            </code>
          </div>
        </section>
      )
    }
  </main>
</Layout>

<!-- Styles remain the same -->
<style>
  /* ... existing styles ... */
  h1 {
    border-bottom: 1px dashed;
    margin: 0 0 0.5em 0;
    padding-bottom: 0.3em;
    font-size: 1.8em;
    font-weight: normal;
  }
  h1 span {
    font-family: "Source Code Pro", monospace;
  }
  h1 a {
    font-size: 0.7em;
    padding-left: 1em;
    font-family: sans-serif;
    font-weight: normal;
    text-decoration: none;
    color: #888;
  }
  h1 a:hover {
    color: #000;
  }

  .alias-note {
    font-style: italic;
    color: #666;
    margin: -0.5em 0 1em 0;
    font-size: 0.9em;
  }
  .alias-note a {
    color: #444;
  }

  h2 {
    font-size: 1.4em;
    margin: 1.5em 0 0.5em 0;
    padding: 0 0 0.2em 0;
    border-bottom: 1px solid;
    font-weight: normal;
  }

  section {
    margin-bottom: 1.5em;
  }

  #tldDocs {
    margin: 1em 0 2em 0;
    line-height: 1.6;
  }
  .docs p {
    margin: 0.5em 0;
  } /* Basic paragraph spacing */

  /* Function Proto / Source Code */
  .fn-proto,
  .doctest,
  .source-code {
    background-color: #f8f8f8;
    border: 1px solid #e8e8e8;
    padding: 0.5em 1em;
    overflow-x: auto;
    margin-top: 0.5em;
  }
  pre {
    margin: 0;
  }
  code {
    font-family: "Source Code Pro", monospace;
    font-size: 0.95em;
  }

  /* Params, Fields, Errors */
  #listParams > .param-entry,
  #listFields > .field-entry,
  #tableFnErrors > .error-entry, /* Style individual errors */
  #listErrSetErrors > .error-entry {
    border-bottom: 1px solid #eee;
    padding: 0.8em 0.5em;
    line-height: 1.5;
  }
  #listParams > .param-entry:last-child,
  #listFields > .field-entry:last-child,
  #tableFnErrors > .error-entry:last-child,
  #listErrSetErrors > .error-entry:last-child {
    border-bottom: none;
  }
  /* Assuming HTML from WASM contains structure like name, type, docs */
  /* Add more specific styles based on the actual HTML generated */

  /* Nested Members List */
  ul.nested-list {
    column-width: 20em;
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
  ul.nested-list li {
    padding: 0.1em 0;
    overflow-wrap: break-word;
  }
  ul.nested-list a {
    font-family: "Source Code Pro", monospace;
  }
  .nested-category {
    font-size: 0.85em;
    color: #777;
    margin-left: 0.5em;
  }

  /* Breadcrumbs are now handled by ModuleNav component style */

  /* Dark mode */
  @media (prefers-color-scheme: dark) {
    h1 {
      border-bottom-color: #555;
    }
    h1 a {
      color: #aaa;
    }
    h1 a:hover {
      color: #fff;
    }
    .alias-note {
      color: #aaa;
    }
    .alias-note a {
      color: #ccc;
    }
    h2 {
      border-bottom-color: #666;
    }
    .fn-proto,
    .doctest,
    .source-code {
      background-color: #2c2c2c;
      border-color: #444;
    } /* Darker background */
    #listParams > .param-entry,
    #listFields > .field-entry,
    #tableFnErrors > .error-entry,
    #listErrSetErrors > .error-entry {
      border-bottom-color: #333;
    }
    .nested-category {
      color: #aaa;
    }

    /* Dark mode for breadcrumbs handled by ModuleNav component style */
  }
</style>

<script>
  import { codeToHtml } from "shiki";

  const codesElements = document.getElementsByTagName("code");

  await Promise.all(
    Array.from(codesElements).map(async (codeElement) => {
      const codeOriginal = codeElement.innerHTML;
      codeElement.innerHTML = await codeToHtml(codeOriginal, {
        lang: "zig",
        theme: "dracula",
      });
    })
  );
</script>

